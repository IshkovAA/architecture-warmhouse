# Project_template

# Задание 1. Анализ и планирование

### 1. Описание функциональности монолитного приложения

**Управление отоплением:**

- Пользователи могут вызвать специалиста для подключения системы отопления в доме к текущей версии системы
- Пользователи могут управлять датчиками отопления, то есть регулировать температуру в доме
- Пользователи(администраторы) могут получить список всех датчиков
- Пользователи(администраторы) могут отключить/удалить датчик
- Система поддерживает только датчики управления отоплением

**Мониторинг температуры:**

- Пользователи могут проверять температуру в доме

### 2. Анализ архитектуры монолитного приложения

Тип приложения: Монолитное REST API
Язык программирования: Go
База данных: PostgreSQL
Управление идет от сервера к датчику, синхронное взаимодействие

### 3. Определение доменов и границы контекстов

Домен управления датчиками(sensors)
    Контекст:
        - Хранение метаданных датчиков
        - Базовые операции с датчиками(создание, обновление, удаление)

Домен мониторинга температуры
    Контекст:
        - Получение температурных данных

### **4. Проблемы монолитного решения**

- Невозможно масштабировать отдельные модули системы
- Общие ресурсы памяти и CPU
- Единая точка отказа
- Недоступность системы при релизе нового функционала во время деплоя

Для mvp целевой экосистемы подойдет монолитное решение(модульный монолит), этого будет достаточно для нагрузки на систему ("экосистемы умных посёлков на территории нескольких регионов страны" - речь не о сотнях, а о десятках тысяч домов, как максимум, если брать крупные кластеры).
Но допустим, что бизнес готов заранее к росту популярности приложения и в таком случае потребуется подготовиться к масштабированию и выбору микросервисного решения

### 5. Визуализация контекста системы — диаграмма С4

```markdown
[Диаграмма контекста в модели C4 текущего решения](https://postimg.cc/hXB0HqnF)
```

# Задание 2. Проектирование микросервисной архитектуры

В этом задании вам нужно предоставить только диаграммы в модели C4. Мы не просим вас отдельно описывать получившиеся микросервисы и то, как вы определили взаимодействия между компонентами To-Be системы. Если вы правильно подготовите диаграммы C4, они и так это покажут.

**Диаграмма контейнеров (Containers)**

TODO: Диаграмма контейнеров

**Диаграмма компонентов (Components)**

Добавьте диаграмму для каждого из выделенных микросервисов.

**Диаграмма кода (Code)**

Добавьте одну диаграмму или несколько.

# Задание 3. Разработка ER-диаграммы

Добавьте сюда ER-диаграмму. Она должна отражать ключевые сущности системы, их атрибуты и тип связей между ними.

# Задание 4. Работа с docker и docker-compose

Перейдите в apps.

Там находится приложение-монолит для работы с датчиками температуры. В README.md описано как запустить решение.

Вам нужно:

1) сделать простое приложение temperature-api на любом удобном для вас языке программирования, которое при запросе /temperature?location= будет отдавать рандомное значение температуры.

Locations - название комнаты, sensorId - идентификатор названия комнаты

```
	// If no location is provided, use a default based on sensor ID
	if location == "" {
		switch sensorID {
		case "1":
			location = "Living Room"
		case "2":
			location = "Bedroom"
		case "3":
			location = "Kitchen"
		default:
			location = "Unknown"
		}
	}

	// If no sensor ID is provided, generate one based on location
	if sensorID == "" {
		switch location {
		case "Living Room":
			sensorID = "1"
		case "Bedroom":
			sensorID = "2"
		case "Kitchen":
			sensorID = "3"
		default:
			sensorID = "0"
		}
	}
```

2) Приложение следует упаковать в Docker и добавить в docker-compose. Порт по умолчанию должен быть 8081

3) Кроме того для smart_home приложения требуется база данных - добавьте в docker-compose файл настройки для запуска postgres с указанием скрипта инициализации ./smart_home/init.sql

Для проверки можно использовать Postman коллекцию smarthome-api.postman_collection.json и вызвать:

- Create Sensor
- Get All Sensors

Должно при каждом вызове отображаться разное значение температуры

Ревьюер будет проверять точно так же.

--------
Пятое задание — дополнительное. Его можно сделать по желанию. Чтобы ревьюер быстрее проверил ваше решение, укажите, сделали вы это задание или нет. Для этого оставьте нужный эмодзи около заголовка задания:

✅ — вы выполнили задание.

❌ — вы пропустили задание.

# ❌ Задание 5. Создание и документирование API

### 1. Тип API

Укажите, какой тип API вы будете использовать для взаимодействия микросервисов. Объясните своё решение.

### 2. Документация API

Здесь приложите ссылки на документацию API для микросервисов, которые вы спроектировали в первой части проектной работы. Для документирования используйте Swagger/OpenAPI или AsyncAPI.
