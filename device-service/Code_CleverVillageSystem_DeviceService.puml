@startuml
title Device Service Architecture

package "service" {
    class ModuleLogicService {
        - persistenceService: ModulePersistenceService
        - messagingService: ExternalSystemMessagingService
        --
        + ProcessMessage(event: schemas.BaseEvent): (bool, error)
        + TurnOnModule(houseID: uuid.UUID, moduleID: uuid.UUID): error
        + TurnOffModule(houseID: uuid.UUID, moduleID: uuid.UUID): error
        + GetModuleState(houseID: uuid.UUID, moduleID: uuid.UUID): *web_schemas.HouseModuleState
        + GetAllModules(): []web_schemas.ModuleOut
        + GetModulesByHouseID(houseID: uuid.UUID): []web_schemas.ModuleOut
    }

    class ModulePersistenceService {
        - repository: repository.ModuleRepository
        --
        + GetAllModules(): []web_schemas.ModuleOut
        + GetModulesByHouseID(houseID: uuid.UUID): []web_schemas.ModuleOut
        + GetModuleState(houseID: uuid.UUID, moduleID: uuid.UUID): *web_schemas.HouseModuleState
        + TurnOnModule(houseID: uuid.UUID, moduleID: uuid.UUID): error
        + TurnOffModule(houseID: uuid.UUID, moduleID: uuid.UUID): error
        + AcceptAdditionModuleToHouse(houseID: uuid.UUID, moduleID: uuid.UUID): error
        + FailAdditionModuleToHouse(houseID: uuid.UUID, moduleID: uuid.UUID): error
    }

    class ExternalSystemMessagingService {
        - supplier: suppliers.KafkaSupplierInterface
        --
        + SendModuleAdditionEvent(ctx: context.Context, key: []byte, event: schemas.HomeVerificationEvent): error
        + SendEquipmentStateChangeEvent(ctx: context.Context, key: []byte, event: schemas.ChangeEquipmentStateEvent): error
        + ReadModuleVerificationEvent(ctx: context.Context): schemas.BaseEvent
    }
}

package "repository" {
    interface ModuleRepository {
        + GetAllModules(): []web_schemas.ModuleOut
        + GetModulesByHouseID(houseID: uuid.UUID): []web_schemas.ModuleOut
        + GetModuleState(houseID: uuid.UUID, moduleID: uuid.UUID): *web_schemas.HouseModuleState
        + TurnOnModule(houseID: uuid.UUID, moduleID: uuid.UUID): error
        + TurnOffModule(houseID: uuid.UUID, moduleID: uuid.UUID): error
        + AcceptAdditionModuleToHouse(houseID: uuid.UUID, moduleID: uuid.UUID): error
        + FailAdditionModuleToHouse(houseID: uuid.UUID, moduleID: uuid.UUID): error
    }

    class GORMModuleRepository {
        --
        + GetAllModules(): []web_schemas.ModuleOut
        + GetModulesByHouseID(houseID: uuid.UUID): []web_schemas.ModuleOut
        + GetModuleState(houseID: uuid.UUID, moduleID: uuid.UUID): *web_schemas.HouseModuleState
        + TurnOnModule(houseID: uuid.UUID, moduleID: uuid.UUID): error
        + TurnOffModule(houseID: uuid.UUID, moduleID: uuid.UUID): error
        + AcceptAdditionModuleToHouse(houseID: uuid.UUID, moduleID: uuid.UUID): error
        + FailAdditionModuleToHouse(houseID: uuid.UUID, moduleID: uuid.UUID): error
    }
}

package "suppliers" {
    interface KafkaSupplierInterface {
        + SendMessageToAdditionTopic(ctx: context.Context, key: []byte, event: schemas.HomeVerificationEvent): error
        + SendMessageToEquipmentChangeStateTopic(ctx: context.Context, key: []byte, event: schemas.ChangeEquipmentStateEvent): error
        + ReadModuleVerificationTopic(ctx: context.Context): kafka.Message
    }

    class KafkaSupplier {
        --
        + SendMessageToAdditionTopic(ctx: context.Context, key: []byte, event: schemas.HomeVerificationEvent): error
        + SendMessageToEquipmentChangeStateTopic(ctx: context.Context, key: []byte, event: schemas.ChangeEquipmentStateEvent): error
        + ReadModuleVerificationTopic(ctx: context.Context): kafka.Message
    }
}

ModuleLogicService --> ModulePersistenceService : uses
ModuleLogicService --> ExternalSystemMessagingService : uses
ModulePersistenceService --> ModuleRepository : uses
ModuleRepository <|-- GORMModuleRepository : implements
ExternalSystemMessagingService --> KafkaSupplierInterface : uses
KafkaSupplierInterface <|-- KafkaSupplier : implements
@enduml
