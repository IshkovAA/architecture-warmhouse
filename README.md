# Project_template

Это шаблон для решения проектной работы. Структура этого файла повторяет структуру заданий. Заполняйте его по мере работы над решением.

# Задание 1. Анализ и планирование

<aside>

Чтобы составить документ с описанием текущей архитектуры приложения, можно часть информации взять из описания компании и условия задания. Это нормально.

</aside

### 1. Описание функциональности монолитного приложения

Анализ основан на уже реализованных методах 

**Управление отоплением:**

- Пользователи (пользователи api, client приложения как админского так и клиентского) могут:
  - Получать список существующих датчиков
  - Получать параметры конкретного датчика по его id
  - Добавлять датчик в систему
  - Обновлять параметры датчика по его id (Name,Type,Location,Value,Unit,Status)
  - Удалять датчик из системы по его id
  - Обновлять значения датчика (Value,Status) по его id 
- Система поддерживает:
  - Обновление данных температурных датчиков из внешнего API
  - Отображение показателей из БД вне зависимости от работоспособности внешенго API
  - Логирование ошибок

**Мониторинг температуры:**

- Пользователи могут:
  - Получать список существующих датчиков
  - Получать параметры конкретного датчика по его id
- Система поддерживает:
  - Обновление данных температурных датчиков из внешнего API
  - Отображение показателей из БД вне зависимости от работоспособности внешенго API
  - Логирование ошибок

### 2. Анализ архитектуры монолитного приложения

Перечислите здесь основные особенности текущего приложения: какой язык программирования используется, какая база данных, как организовано взаимодействие между компонентами и так далее.
- Язык программирования: Go
- База данных: PostgreSQL
- Архитектура: Монолитная, все компоненты системы (обработка запросов, бизнес-логика, работа с данными) находятся в рамках одного приложения.
- Взаимодействие: Синхронное, запросы обрабатываются последовательно.
- Масштабируемость: Ограничена, так как монолит сложно масштабировать по частям.
- Развертывание: Требует остановки всего приложения.

### 3. Определение доменов и границы контекстов

Перенос системы AS IS:
 - Домен: управление устройствами
   - Поддомен: регистрация устройств в системе
     - Контекст: добавление и удаление устройтв
   - Поддомен: управление параметрами устройства
     - Контекст: установка статусов и прочих административных параметров устройства
 - Домен: мониторинг устройств 
   - Поддомен: получение данных с устройств
     - Контекст: получение данных с устройств
   - Поддомен: обновление данных
     - Контекст: обновление данных

TO BE:
 - Домен: управление пользователями
   - Контекст: система авторизации и аутентификации
   - Контекст: регистрация и удаление пользователей
 - Домен: работа с логами
   - Контекст: сбор и сохранение логов


### **4. Проблемы монолитного решения**

- Отсутствие параллельности выполнения независимых задач (например получение данных с датчика и создание нового датчика)
- Сбой в каком либо из програмных компонентов (например обновление температуры из внешнего апи) приводит к сбою всего приложения 
- Отсутствие возможности кастомизации приложения под конкретные типы датчиков. Может быть критично при дальнейшем развитии

- *проблема конкретной реализации*: вызов методов работающих с БД везде с указанием context.Background() вместо указания контекста запроса. 


### 5. Визуализация контекста системы — диаграмма С4

```markdown
[Диаграмма контекста монолитного приложения](diagrams/monolith_context.png)
```

# Задание 2. Проектирование микросервисной архитектуры

В этом задании вам нужно предоставить только диаграммы в модели C4. Мы не просим вас отдельно описывать получившиеся микросервисы и то, как вы определили взаимодействия между компонентами To-Be системы. Если вы правильно подготовите диаграммы C4, они и так это покажут.

**Диаграмма контейнеров (Containers)**

```markdown
[Диаграмма контейнеров микросервисного приложения](diagrams/microservice_containers.png)
```

**Диаграмма компонентов (Components)**

Примеры:
```markdown
[Диаграмма компонентов клиентского веб приложения](diagrams/components/WebApp.png)
[Диаграмма компонентов админского веб приложения](diagrams/components/AdminApp.png)
[Диаграмма компонентов сервиса регистрации умных модулей](diagrams/components/ModuleRegistrationService.png)
```


**Диаграмма кода (Code)**

Пример:
```markdown
[Диаграмма компонентов клиентского веб приложения](diagrams/code/ModuleRegistrationController.png)
```

# Задание 3. Разработка ER-диаграммы

Пример:
```markdown
[Диаграмма компонентов клиентского веб приложения](diagrams/ER.png)
```

# Задание 4. Создание и документирование API

### 1. Тип API

Выбрал API брокера NATS так как предполагается реализация микросервисов на GO.
NATS легкий инструмент хорошо работает с GO и его должно быть достаточно для функционала нашей системы

### 2. Документация API

Документация на AsyncAPI для очереди сообщений реализованной с помощью NATS

Пример:
```markdown
[Документация работы брокера сообщений](API_DOC\queue.yaml)
```

# Задание 5. Работа с docker и docker-compose

Перейдите в apps.

Там находится приложение-монолит для работы с датчиками температуры. В README.md описано как запустить решение.

Вам нужно:

1) сделать простое приложение temperature-api на любом удобном для вас языке программирования, которое при запросе /temperature?location= будет отдавать рандомное значение температуры.

Locations - название комнаты, sensorId - идентификатор названия комнаты

```
	// If no location is provided, use a default based on sensor ID
	if location == "" {
		switch sensorID {
		case "1":
			location = "Living Room"
		case "2":
			location = "Bedroom"
		case "3":
			location = "Kitchen"
		default:
			location = "Unknown"
		}
	}

	// If no sensor ID is provided, generate one based on location
	if sensorID == "" {
		switch location {
		case "Living Room":
			sensorID = "1"
		case "Bedroom":
			sensorID = "2"
		case "Kitchen":
			sensorID = "3"
		default:
			sensorID = "0"
		}
	}
```

2) Приложение следует упаковать в Docker и добавить в docker-compose. Порт по умолчанию должен быть 8081

3) Кроме того для smart_home приложения требуется база данных - добавьте в docker-compose файл настройки для запуска postgres с указанием скрипта инициализации ./smart_home/init.sql

Для проверки можно использовать Postman коллекцию smarthome-api.postman_collection.json и вызвать:

- Create Sensor
- Get All Sensors

Должно при каждом вызове отображаться разное значение температуры

Ревьюер будет проверять точно так же.


